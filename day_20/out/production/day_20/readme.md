## 多线程

### 创建多线程
>只需要继承就可以了 可以并发执行
 
 1. 第一种： 编写一个类， 直接继承java.lang.Thread 重写run 方法
 
  创建线程？ new
  启动线程？ 调用start方法
 ```java
public class Threads {
    public static void main(String[] args) {
         // 这里是main 方法，这里的代码属于主线程，在主栈运行
         // 新建Hige分支线程
         MyThread myThread = new MyThread();
         // 启动线程
         // start() 方法的作用是 启动一个分支线程，在jvm 中开辟一个新的空间栈，立马结束
         // 启动成功的线程会自动调用run方法， 并且run 方法在分支栈的栈底部（压栈）
        // run 方法在分支栈的底部，main 方法主栈的栈底部，run 和main 是平级的
        myThread.start(); //两个for是同时执行的 在不同的栈道
         // 这里运行主线程
        for (int i = 0; i <4 ; i++) {
            System.out.println("主线程");
        }
    }
}

```
 
 2. 第二种：编写一个类， 实现java.lang.Runnable 接口，实现Run方法


## 并发基础

### 同步

1. synchronized 关键字

synchronied 
静态同步方法： 锁的是大年类型的类队形，在本代码中你就是test_02.calss


```
 线程同步机制语法是
 synchronized(谁的共享对象){
     // 线程同步代码块
     这个数据必须是多线程共享的数据，才能达到多线程排队
 }
 ```

 `()中写什么？`

那需要看你让那些线程同步。
假如t1 t2 t3 需要排队，t4 t5 不需要排队？
你一定要在（）中写一个 t1 t2 t3 共享的对象，而这个对象对于t3 t4 不是共享的。

这里是账户是共享对象，可能是this 可能是其他共享对象

synchronized 执行原理？
  1. 假设t1 和 t2 线程并发。开始执行以下代码的时候，肯定有一个先。一个后。
  2. 假设t1 先执行了，遇到了synchronized 这个时候自动找，"后面共享对象"的对象锁， 找到之后并占有这把锁。
  3. 然后执行同步代码块中的程序，在程序执行过程中一直都是占有这把锁，知道同步代码块结束，才会把这个锁释放。
  4. 假设t1 已经占有这把锁，t2 也遇到了synchronized ，关键字，也会企业占有后面共享对象的这把锁。结果这把锁被t1 占有。t2 只能在在同步代码块执行结束了，t1 会归还这把锁，此时t2 终于等到这把锁执行结束，才能进入代码块
  5. 需要注意的是，这共享对象一定要选好了，这个共享对象一定是需要排队执行的这些线程对象锁共享的
         
 类锁永远只有一把锁，对像锁有n 个，每个对象一个
 当synchronized 方法出现在方法中可以吗？
   *  synchronized  出现在实例方法上，一定锁的是this,没得挑， 只能是this，不能是其他对象。所以这种方式不灵活。
   *  另外还有一个缺点： synchronized 出现在实例方法上，表示整个方法都是需要同步的，可能Juin无故扩大同步的范围，导致程序执行效率底下。
   * 优点： 代码少


 ## 数据安全是重点
 
 1. 发生条件？
  * 多线程并发
  * 共享数据
  * 共享数据有修改的行为
 
 2. 怎么解决线程安全问题呢？
  当多线程并发的环境下，有共享数据，并且这个数据还会被修改，此时就会有线程安全问题
  * 线程同步机制：  线程排队执行（不能并发）
 
 3.  编程模型
   1. 异步编程模型 （并发）
   2. 同步编程模型
 
 Java 中有三大变量？
 
 实例变量： 在堆中
 静态变量： 在方法区中
 局部变量： 在栈中

 以上三大变量中：
   局部变量永远不会有存在线程安全问题。因为局部变零不会共享（一个线程一个栈）
   静态实例在堆中，堆只有一个方法，
   静态变量在方法区中，方法区只有一个。
   堆和方法区都是多线程共享的，所以可能存在线程安全的问题。
 
   局部变量 + 常量： 不会有线程安全问题
   成员变量： 可能会有线程安全问题
 
 4. 如果使用局部变量的话： 建议使用StringBuilder
 因为局部变量不存在安全问题，选择StringBuilder  StringBuilder效率比较低
 ```
 ArrayList  是非线程安全的
 Vector 是线程安全的
 HashMap HaseSet 是非线程安全的
 Hashtable 是线程安全的
 ```
 
 5. 总结
 
 Synchronized 有三种写法：
 ```
   第一种： 同步代码块
   synchronized(线程共享对象){
       同步代码块
   }
```
```
   第二种： 在实例的方法上使用synchronized
      表示共享对象一定是this
      并且同步代码块是整个方法体
```
```
   第三种： 在静态方法上使用synchronized表示找类锁
   类所永远只有一把。对象锁 每个对象都有
```
 6. 我们应该怎么解决线程安全问题

 7. 守护线程？
 分为：
   用户线程
   守护线程
     其中具有代表性的就是： 垃圾回收线程（守护线程）

   特点： 一般守护线程就是一个死循环，所有的用户线程只要结束，守护线程自动结束
   注意： 主线程main方法是一个用户线程。
   在什么地方：
      每天零点的视乎系统自动备份。
      这个需要使用到定时器，并且我可以将定时器设置为守护进程。
      一直在那里看着，没到00.00 的时候就备份一次，所有的用户线程如果结束了，
      守护线程自动退出，没有必要进行数据备份了。

## 线程状态

![](../img/QQ20201114-112527@2x.png)

![](../img/QQ20201114-112609@2x.png)

![](../img/WX20210312-115944@2x.png)

![](../img/QQ20210313-202024@2x.png)

加锁的目的就是保证操作的原子性

## 死锁
死锁是指两个或两个以上的线程，在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞现象，若无外力作用，他们都将无推进，此时系统处于死锁状态或系统产生了死锁。这些永远在互相平等的进程成为死锁。 

2 volatile 关键字

3 wait& notify 

4 AtomicXxx 类型组

5 CountDownLath 门闩